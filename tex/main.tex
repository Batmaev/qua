\input{./gost-template/preamble.tex}

\usepackage{microtype}
\usepackage[extdef]{delimset}
\usepackage{csquotes} % иначе babel делает ворнинг
\usepackage{ragged2e}
\usepackage[hidelinks]{hyperref}
%\usepackage{software-biblatex}

\DeclareMathOperator{\Rx}{Rx}
\DeclareMathOperator{\Ry}{Ry}
\DeclareMathOperator{\Rz}{Rz}

\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator{\arctantwo}{arctan2}


\begin{document}

\setcounter{page}{2}

\hidedstructel{АННОТАЦИЯ}

% Пояснительная записка \pageref{LastPage} с., \total{figcount} рис.,
% \total{tblcount} табл., \total{bibcount} источн., \total{annexcount} прил.

Разработан приближённый квантовый алгоритм для задачи коммивояжёра. Данный алгоритм относится к вариационным. Он имеет сложность $O(n^2 \log n)$ ($n$ --- число городов) и требует $O(n \log n)$ кубитов. Наш алгоритм оказывается производительнее простого перебора и может быть запущен на квантовых компьютерах при текущем уровне развития технологий.

Также был разработан способ представления маршрутов на квантовом компьютере, опирающийся на лексикографическое упорядочивание. Данное представление позволяет автоматически, без введения штрафных слагаемых, учитывать нетривиальные ограничения задачи коммивояжёра, касающиеся того, чтобы маршрут проходил через все города по одному разу и не распадался на не связанные между собой петли. 

\input{./gost-template/toc.tex}

\structel{ВВЕДЕНИЕ}

Квантовый компьютер манипулирует кубитами. Состоящие из кубитов компьютерные регистры могут находиться в суперпозиции нескольких состояний. Когда квантовый компьютер производит вычисление над суперпозицией, он производит вычисление над всеми состояниями одновременно \cite{quantumComputers}. Это делает квантовые компьютеры привлекательными для задач, в которых требуется перебор большого числа вариантов. 

В этой работе мы попытаемся решить задачу коммивояжёра.

Будем искать решение в классе вариационных квантовых алгоритмов \cite{VQA}. В них квантовый компьютер запускается снова и снова с небольшими изменениями в параметрах квантовой цепи. Процессом варьирования управляет классический компьютер. Его задача --- подобрать параметры цепи такие, чтобы на выходе получалось оптимальное по некоторому заданному критерию состояние.

Уже разработаны вариационные квантовые алгоритмы для задач из нескольких разных областей. Среди них --- алгоритмы поиска собственных значений матрицы \cite{VQE}, максимального разреза графа \cite{MaxCut} и другие. Они позволяют решать задачи на существующих квантовых компьютерах --- подверженных шумам и оперирующих малым числом кубитов.

Для задачи коммивояжёра, которой посвящена данная работа, эффективного квантового алгоритма пока не существует. 

Особенностью этой задачи является наличие ограничений: например, коммивояжёр не может посетить один город дважды. Традиционно ограничения в вариационных квантовых алгоритмах реализуются через дополнительные штрафные слагаемые к оптимизируемой величине \cite{QUBO-TSP, QUBO-TSP2, PenaltiesInVQE}. Но мы вместо этого попробуем добиться того, чтобы состояние, не удовлетворяющее ограничениям, в принципе невозможно было измерить.

Такая реализация ограничений задачи непосредственно через саму квантовую цепь --- главное направление этой работы.
%, в этом заключается её новизна и возможная научная значимость.

Настоящие квантовые компьютеры всё ещё не широко доступны, поэтому мы тестируем алгоритм с помощью компьютерной симуляции. Для этого мы используем \texttt{cirq} --- библиотеку для Python от Google Quantum AI \cite{cirq}.

\sect{Классические подходы}

\subsect{Постановка задачи коммивояжёра}

В задаче коммивояжёра есть $n$ городов, соединённых друг с другом, и требуется найти кратчайший маршрут, проходящий через все города по одному разу.

Существует несколько вариаций задачи. Маршрут может быть замкнутым или незамкнутым, расстояния между городами могут подчиняться или не подчиняться неравенству треугольника; граф городов может быть полным или неполным, ориентированным или неориентированным. Все эти разновидности можно свести друг к другу, поэтому мы можем выбрать ту формулировку, которая кажется наиболее удобной. 

Итак, пусть каждый город соединён с каждым (т.е. граф городов полный), пусть мы ищем незамкнутый маршрут и пусть граф городов ориентированный. Ориентированность означает, что условная длина (или стоимость) пути из города $A$ в город $B$ необязательно равна стоимости пути из $B$ в $A$.

Введём обозначение
\[
l_{ij} - \text{ длина пути из $i$-того города в $j$-тый}
\]

Ответом на задачу служит последовательность городов. Есть $n$ способов выбрать первый город, $n-1$ способ выбрать второй и так далее --- всего $n!$ возможных ответов. Если бы мы выбрали другую формулировку задачи, то пришлось бы, например, учитывать, что в замкнутом пути начальную точку можно выбрать несколькими способами.

Простейший алгоритм --- перебрать все возможные перестановки --- будет иметь сложность $O(n!)$ по времени и $O(1)$ по памяти.

\subsect{Алгоритм Хелда--Карпа}

Альтернативой является алгоритм Хелда--Карпа, который имеет сложность $O(n^2 2^n)$ по времени и $O(n 2^n)$ по памяти. Это лучший классический алгоритм из тех, которые гарантированно приходят к точному решению.\footnote{Ещё есть эвристические приближённые алгоритмы} Рассмотрим его подробнее, чтобы лучше понять, с чем мы соревнуемся.%, когда пытаемся разработать квантовый алгоритм.

Для нашей постановки задачи алгоритм
% Хелда--Карпа 
выглядит следующим образом:

\begin{enumerate}

    \item Создаётся мнимый нулевой город, связанный со всеми остальными городами дорогами длины 0.
    
    \item Определяется рекурсивная функция $g(S, e)$, возвращающая длину наименьшего пути, начинающегося в городе 0, проходящего через каждый город некоторого подмножества городов $S$ и заканчивающегося в городе $e \notin S$. 
    
    \item Эта функция вычисляется следующим образом:
    \[
    g(S,e) = \min_{e' \in S} \brk[c]2{
        g(S\backslash e',\, e') + l_{e'e}
    }
    \]
    (через перебор всех возможных вариантов для предпоследнего города $e'$)

    \item Существует $2^n$ возможных множеств $S$. Если последовательно вычислять $g(S,e)$ от меньших множеств к большим, перебирая все $e \notin S$, то мы сможем использовать уже вычисленные значения $g$, и <<входить в рекурсию>> не потребуется. Функция $g$ будет вызвана $O(n2^n)$ раз, и на хранение результатов потребуется $O(n2^n)$ памяти.
    
    \item При каждом вызове функции $g(S,e)$ происходит перебор $O(n)$ возможных предпоследних вершин $e'$, поэтому сложность функции $g$ --- $O(n)$, а сложность алгоритма в целом --- $O(n^2 2^n)$.
    
    \item В конце вычисляется $g(S_{\text{all}}, 0)$, где $S_{\text{all}}$ --- множество всех городов. Это и будет длиной искомого минимального пути.
    
    \item Можно восстановить и сам оптимальный путь, а не только его длину, если в ходе решения помимо промежуточных значений функции $g(S,e)$ сохранять номера оптимальных предпоследних вершин $e'$. Это не повлияет на асимптотику алгоритма.

\end{enumerate}

Алгоритм Хелда--Карпа работает быстрее, чем простой перебор, но требует экспоненциально много памяти. % Поэтому нельзя просто 


\sect{Обзор литературы}

\subsect{Решение на основе алгоритма Гровера}

Один из способов решить задачу коммивояжёра на квантовом компьютере --- это использовать алгоритм Гровера. Это известный квантовый алгоритм, который позволяет «отфильтровать» состояния, удовлетворяющие какому-либо критерию. При этом достигается квадратичное ускорение по сравнению с полным перебором: если всего состояний $N$, а $k$ из них удовлетворяют критерию, то время работы алгоритма составит $O \brk!{\sqrt{N/k}}$.

На основе алгоритма Гровера можно создать алгоритм поиска минимума дискретной функции, которую в данной работе мы будем называть стоимостью. 

В самом деле, мы можем выбрать какое-то произвольное решение, отфильтровать все решения со стоимостью меньше, чем у выбранного, и повторить процесс. В работе \citeauthor{GroverMinima} \cite{GroverMinima} показано, что мы придём к минимуму за $O\brk!{\sqrt N}$ итераций с вероятностью не меньше 50\%.

Осталось применить квантовый алгоритм поиска минимума к задаче коммивояжёра, для этого нужно разработать квантовую схему, которая будет вычислять стоимость маршрута и сравнивать её с пороговой. 

В \citeyear{IBM} году Srinivasan et al. \cite{IBM} предложили вычислять стоимость маршрута, закодировав стоимости индивидуальных рёбер в виде сдвигов фаз $e^{i l_{ij}}$ так, чтобы суммарный набег фазы у квантового состояния $e^{i l_{i_1 j_1}} \cdot e^{i l_{i_2 j_2}} \dots = e^{iL}$ был пропорционален суммарной стоимости маршрута, и применив затем квантовый алгоритм оценки фазы, родственный преобразованию Фурье.

А схему для сравнения стоимости с пороговой разработали Gilliam et al. в \citeyear{GAS} году \cite{GAS}. Они предложили вычислять разность и отслеживать бит знака. Вычитание они реализовали через квантовое преобразование Фурье.

Главной проблемой описанного решения на основе алгоритма Гровера является то, что его сложность
$O\brk!{\sqrt{N}} = O\brk!{\sqrt{n!}}$ хуже, чем сложность классического алгоритма Хелда--Карпа $O(n^2 2^n)$ (рис. \ref{GroverHeld}).

\fig[0.7]{GroverHeld}{Сложность квантового алгоритма решения задачи коммивяжёра на основе алгоритма Гровера $\brk!{O(\sqrt{n!})}$, и сложность классического алгоритма Хелда--Карпа $O(n^2 2^n).$}


\subsect{Квантовый алгоритм Хелда--Карпа}

Классический алгоритм Хелда--Карпа оказался эффективнее квантово ускоренного простого перебора. 
Возникает вопрос: можно ли тогда на квантовом компьютере ускорить сам алгоритм Хелда--Карпа?

В работе \cite{quantHeldKarp} приведён такой алгоритм. Идея авторов заключается в том, чтобы сначала найти решения для части подмножеств городов, а затем использовать алгоритм Гровера и квантовый алгоритм поиска минимума на остальных подмножествах, чтобы найти ответ на задачу. В результате получается сложность $O^*(1.728^n).$

Другой алгоритм приведён в работе \cite{boundedDegreeGraphs}. Авторы рассматривали только графы с ограниченной степенью, это позволило им дополнительно ускорить алгоритм Хелда--Карпа, используя квантовый аналог поиска с возвратом. Им удалось получить сложность $O^*(1.110^n)$ для графов степени 3; \ $O^*(1.301^n)$ для графов степени 4; \ $O^*(1.680^n)$ для графов степени 5 и 6.

Основной проблемой этих алгоритмов (помимо их экспоненциальной сложности), является то, что им требуется доступ к квантовой памяти. К сожалению, на данный момент реализаций квантовой памяти не существует.


\subsect{Квантовый отжиг}

D-Wave Systems, единственная коммерчески успешная квантовая компания, продаёт устройства, предназначенные для квантового отжига. Эти устройства производят адиабатические квантовые вычисления и способны решать задачу квадратичной бинарной оптимизации без ограничений (QUBO). Другие задачи с их помощью решить нельзя, поэтому задачу коммивояжёра имеет смысл переформулировать как QUBO.

Задача QUBO формулируется следующим образом: нужно найти минимум функции
$$
f(\vec x) = \sum_i a_i x_i + \sum_{i,j} c_{ij} x_i x_j
$$
где $x_i \in \brk[c]{0, 1}$ --- бинарные переменные, $a_i$ и $c_{ij}$ --- постоянные коэффициенты.
Линейные члены $a_i x_i$ можно не писать отдельно, если заметить, что для бинарных переменных $x_i = x_i^2$.

Один из простейших способов \cite{allQUBOs} переформулировать задачу коммивояжёра как QUBO --- это ввести бинарные переменные
$$
x_{i t} = 
\begin{cases}
    1, &\text{если на шаге $t$ посещён город $i$} \\
    0 &\text{в остальных случаях}
\end{cases}
$$
В таком случае стоимость пути будет равна
$$
C = \sum_{i,j,t} l_{ij} x_{i, t} x_{j,\, t+1}
$$
Должно быть выполнено ограничение $\sum\limits_i x_{it} = 1 \;\forall t$ (в каждый момент времени посещён один город) и $\sum\limits_t x_{it} = 1 \;\forall i$ (каждый город посещён один раз). Чтобы обеспечить их выполнение, к стоимости пути добавляют штрафные слагаемые:
$$
\tilde C = C + p \cdot \brk2{1 - \sum_i x_{it}}^2 + p \cdot \brk2{1 - \sum_t x_{it}}^2,
$$
Константа $p$ должна быть достаточно большой, чтобы нельзя было получить преимущество, нарушив ограничения. В частности, должно быть выполнено 
$$p > \max_{ij} l_{ij}$$

Другой способ выбрать бинарные переменные приведён в работе \cite{QUBO-TSP}: % (\citeyear{QUBO-TSP}):
$$
x^t_{u, v} =
\begin{cases}
    1, & \text{если на шаге $t$ коммивояжёр перемещается из города $u$ в город $v$} \\
    0 &\text{в остальных случаях}
\end{cases}
$$

В таком случае необходимо отслеживать, чтобы маршрут не распадался на не связанные между собой петли.
% (рис.)?
Для этого необходимо, чтобы город, в который коммивояжёр прибыл на шаге $t$, и город, который он покинул на шаге $t+1$, совпадали. Авторы работы \cite{QUBO-TSP} (\citeyear{QUBO-TSP}) выводят соответствующий громоздкий штрафной член.

Недостатком алгоритмов квантового отжига (помимо наличия штрафных членов) является то, что время работы быстро растёт с увеличением размера задачи и уменьшением промежутков между решениями. В типичных задачах время работы оказывается экспоненциальным \cite{allQUBOs}:
$$
T = O\brk1{\exp\brk{\alpha n ^ \beta}}
$$
Остаётся открытым вопрос, является ли квантовый отжиг хоть немного более эффективным, чем классические алгоритмы.

В данной работе мы не будем ограничиваться QUBO-формулировкой задачи коммивояжёра и придумаем своё кодирование. Это позволит избежать введения штрафных членов.

\subsect{Quantum Approximate Optimization Algorithm}

Quantum Approximate Optimization Algorithm (QAOA) \cite{QAOA} --- вариационный алгоритм, первоначально предложенный для задачи о максимальном разрезе графа. QAOA --- это единственный вариационный квантовый алгоритм, для которого доказано, что в пределе бесконечно глубокой цепи с его помощью можно получить точное решение.

Идея алгоритма заключается в том, чтобы выбрать два гамильтониана: перемешивающий гамильтониан $\hat B$ и гамильтониан оптимизируемой величины~$\hat C$. Пусть начальное состояние системы было основным для гамильтониана~$\hat B$. Тогда при эволюции под воздействием гамильтониана
\begin{equation}
\hat H(t) = (1-t/T) \cdot \hat B + (t/T) \cdot \hat C
\label{adiab}
\end{equation}
система перейдёт в основное состояние гамильтониана $\hat C$ по адиабатической теореме из квантовой механики, если время $T$ достаточно большое.

Однако реализовать непрерывно меняющийся гамильтониан \eqref{adiab} на~квантовом компьютере может быть сложно, поэтому в алгоритме QAOA используют аппроксимацию, в которой эволюция под воздействием $\hat B$ и $\hat C$ происходит поочерёдно:
$$
\hat U = \dots e^{i \beta_2 \hat B} e^{i \gamma_2 \hat C} \cdot e^{i \beta_1 \hat B} e^{i \gamma_1 \hat C}
$$

Промежутки времени $\gamma_i$ и $\beta_i$ являются вариационными параметрами, которые необходимо подобрать путём многократных запусков.

Обычно в качестве перемешивающего гамильтониана берут сумму однокубитных операторов $\hat X = \hat \sigma_x = \operatorname{NOT}$:
$$
\hat B = \bigoplus_i \hat X_i
\qquad
e^{- i \beta \hat B} = \bigotimes_i \Rx(\beta)
$$
а в качестве начального состояния --- равную суперпозицию всех состояний:
$$
\ket{\psi_0} = 
\brk3{
    \frac{\ket{0} + \ket{1}}{\sqrt 2}
}^{\otimes\, m}
$$

\parag{Подход с использованием штрафных слагаемых}

Один из способов применить алгоритм QAOA к задаче коммивояжёра~--- это переформулировать её как задачу QUBO со штрафными слагаемыми подобно тому, как описано в пункте «Квантовый отжиг». Такой подход применяется в работах \cite{Stanford1, stanford2} и на домашней странице Джека Церони \cite{HomePage}.

Важным свойством QUBO-формулировки является то, что гамильтониан $\hat C$ оказывается записан в виде суммы коммутирующих слагаемых:
$$
\hat C = \sum_{i,j} c_{ij} \cdot \hat q_i \otimes \hat q_j
\qquad
\hat q = \ket{1}\bra{1},
$$
где индексы означают номер кубита. 
Поскольку для коммутирующих операторов $e^{\hat x + \hat y} = e^{\hat x} \cdot e^{\hat y}$, это позволяет выразить оператор эволюции $e^{i \gamma \hat C}$ через операторы эволюции для отдельных слагаемых. Эти операторы являются двухкубитными и их можно реализовать на квантовом компьютере; они выражаются через гейты CNOT и Rz.

Однако, такие алгоритмы требуют $O(n^2)$ кубитов. Ни в одной из цитируемых работ не удалось промоделировать графы с числом городов больше четырёх. 

\parag{Quantum Alternating Operator Ansatz}

Quantum Alternating Operator Ansatz \cite{Alternating} (\citeyear{Alternating}) является расширением Quantum Approximate Optimization Algorithm, оба алгоритма сокращаются как QAOA.

В расширенной версии алгоритма предлагается реализовать ограничения задачи следующим образом. Начальным состоянием должна быть не равная суперпозиция всех $2^m$ состояний, а какое-либо одно допустимое решение. Далее, как и в старом алгоритме, поочерёдно применяются операторы $e^{i \beta_i \hat B}$ и $e^{i \gamma_i \hat C}$. Разница заключается в том, что теперь оператор $\hat B$ должен переводить допустимые решения в допустимые. В случае задачи коммивояжёра авторы работы \cite{Alternating} предлагают использовать в качестве оператора $\hat B$ различные комбинации SWAP-гейтов. 

Авторы работы \cite{oracle} (\citeyear{oracle}) идут более сложным путём и конструируют квантовый оракул, который определяет, является ли решение допустимым маршрутом. Затем они конструируют с его помощью перемешивающий гамильтониан $\hat B$ в виде
$$
\hat B = \sum_{\ket{x}, \ket{x'} \in F} \brk2{\ket{x'}\bra{x} + \ket{x}\bra{x'}},
$$
где $F$ --- множество допустимых решений.

Quantum Alternating Operator Ansatz позволяет избавиться от штрафных слагаемых в гамильтониане, так как состояния, не удовлетворяющие ограничениям, просто не возникают. Изначально я собирался использовать именно этот алгоритм в данном дипломе, но я не был удовлетворен результатами и разработал своё решение с нуля.

\sect{Описание алгоритма}

На рисунке \ref{overview} приведена общая схема нашего алгоритма. В начале некоторыми практически произвольными параметрическими гейтами создаётся суперпозиция нескольких возможных маршрутов. Затем кубиты измеряются. Это происходит несколько раз, и на классическом компьютере вычисляется средняя стоимость маршрута.

\fig[0.96]{overview}{Общая схема нашего алгоритма}

Основываясь на средней стоимости, мы обновляем параметрические гейты и запускаем цепь заново в надежде, что средняя стоимость уменьшится. Здесь мы можем следовать любому численному алгоритму нахождения минимума функции. 
%Мы используем алгоритм Rotosolve (Ostaszewski et al, \citedate{rotosolve})
Лучше всего себя показал алгоритм Rotosolve 
%\cite{rotosolve}, 
(Ostaszewski et al, \citedate{rotosolve}),
который опирается на то, что все квантовые гейты --- унитарные, и, следовательно, функция $\brk[a]{\text{cost}} = f(\theta_1, \theta_2 \dots)$ (зависимость средней стоимости от параметров гейтов) не совсем произвольная.

Квантовый компьютер нужен для того, чтобы преобразовать пространство поиска. Исходная задача была дискретной, но, добавив «прослойку» в виде квантового компьютера, мы преобразовали её к непрерывной (рис. \ref{transformation}). Это позволяет применять всё многообразие градиентных и неградиентных методов оптимизации, в том числе выбранный нами алгоритм Rotosolve.

\fig[0.66]{transformation}{Введение квантового компьютера 
%и вариационных параметров $\theta_i$ 
позволяет преобразовать дискретную задачу к непрерывной}


Рассмотрим теперь детали нашего решения.



\subsect{Представление маршрутов на квантовом компьютере}

Коротко: все возможные маршруты можно занумеровать в лексикографическом порядке. Этот номер кодируется на квантовом компьютере, для чего требуется $\lceil \log_2 n! \rceil$ кубитов. В конце схемы кубиты измеряются, и на классическом компьютере номер маршрута переводится в факториальную систему счисления, затем вычисляется сам маршрут и его стоимость.

% %В данном подразделе процедура кодирования-декодирования описывается детально.

Рассмотрим эту процедуру подробнее.

% Обсудим связь между маршрутом и его номером.

% Рассмотрим для примера случай трёх городов.

\parag{Маршруты как перестановки}

Мы выбрали вариант задачи коммивояжёра, в котором требуется найти незамкнутый маршрут в полном ориентированном графе. Корректным маршрутом является любая последовательность посещённых городов, в которой каждый город встречается по одному разу --- то есть любая из $n!$ перестановок городов. В нашей формулировке задачи между маршрутами и перестановками есть взаимно однозначное соответствие; мы можем использовать эти слова как синонимы.

%Если присвоить городам номера, то можно расположить все перестановки в лексикографическом («алфавитном») порядке и пронумеровать их тоже.

Присвоим городам номера от 0 до $n-1$.

Перестановки можно строить с помощью дерева (рис. \ref{tree}): в начале мы выбираем первый город из $n$ вариантов, затем с каждым следующим городом количество ветвей уменьшается на 1. Ветви у каждого узла расположены по возрастанию. Перестановки, соответствующие листьям дерева, будут расположены тогда в лексикографическом порядке.

\fig[0.6]{tree}{Все возможные маршруты для случая трёх городов в лексикографическом (т.е. «алфавитном») порядке.}

Поскольку перестановки теперь упорядочены, мы можем их пронумеровать. Номер перестановки удобно записывать в факториальной системе счисления, поскольку эта система отражает структуру дерева вариантов. 

\parag{Факториальная система счисления}

Обсудим факториальную систему счисления. В этой системе последняя цифра должна быть из множества $\brk[c]{0, 1}$, вторая с конца --- из $\brk[c]{0, 1, 2}$, третья --- из $\brk[c]{0, 1, 2, 3}$ и так далее. Если в десятичной системе цифры умножаются на числа 1, 10, $10^2$ и так далее, то в факториальной --- на числа 1!, 2!, $3!$\dots:
$$
\overline{\dots cba}_! = a \cdot 1! + b \cdot 2! + c \cdot 3! \dots
$$

Максимальное число из $n-1$ цифр равно $n!-1$. 
 
Если записать номер перестановки в факториальной системе счисления, то последовательность его цифр можно будет интерпретировать как последовательность выборов в дереве вариантов с рисунка \ref{tree}. 
В самом деле, первая цифра в $n{-}1{-}$значном числе соответствует выбору из $n$ вариантов, вторая --- выбору из $n-1$ варианта, последняя --- выбору из двух вариантов. 
%Легко видеть, что,
Взяв число 
$$a = \overline{a_1 a_2 \dots a_{n-1}}_!$$ 
двигаясь по дереву и выбирая на $k$-том шаге ветвь номер $a_k$, мы придём в конце к перестановке номер $a$.

Таким образом, имея номер перестановки в факториальной системе счисления, мы можем цифра за цифрой восстановить по нему саму перестановку. Хранить факториально большое дерево для этого не нужно: доступные ветви на каждом шаге определяются ещё не использованными городами.

% На практике, однако, проще 

\parag{Процедура декодирования маршрутов}

Вышесказанное позволяет в качестве представления маршрута использовать его номер $c \in [0,\: n!)$. Любое целое число, попадающее в этот промежуток, является валидным маршрутом.

Такое представление выгодно отличается от представления маршрута через его рёбра, которое использовалось в других работах (см. раздел «Обзор литературы»). Наше представление автоматически учитывает нетривиальные ограничения задачи, касающиеся того, чтобы маршрут проходил через все города и не распадался на несвязанные друг с другом петли.

На квантовом компьютере для хранения номера маршрута мы будем использовать двоичную систему счисления, что потребует $\lceil \log_2 n! \rceil = O(n \log n)$ кубитов. 

Хотелось бы построить такую схему, которая генерирует только валидные номера перестановок --- то есть из промежутка $[0,\: n!)$. Однако мы не будем этим себя утруждать и позволим схеме генерировать все номера $b \in [0,\: 2^{\lceil \log_2 n! \rceil}),$ которые могут быть записаны на имеющемся наборе кубитов.

Слишком большие номера перестановок мы реинтерпретируем на классическом компьютере как номера из допустимого множества по формуле
$$c = b \mathbin{\%} n!$$

После измерения мы переводим номер перестановки из двоичной системы в факториальную, используя обычный алгоритм перевода между системами счисления, основанный на делении с остатком.

Затем на классическом компьютере мы вычисляем сам маршрут, а потом, зная маршрут, вычисляем его стоимость. Этот процесс повторяется достаточное количество раз, чтобы вычислить среднюю стоимость состояния, которое в общем случае представляет собой суперпозицию разных маршрутов.

% В нашей схеме используется $m = \lceil \log_2 n! \rceil = O(n \log n)$ кубитов. Мы измеряем их и получаем битовую строку, которую мы интерпретируем как двоичное число $b \in [0,\: 2^m - 1]$.

% На рисунке \ref{tree} изображены все перестановки\footnote{Мы рассматриваем незамкнутые маршруты в полном ориентированном графе, поэтому слова «маршрут» и «перестановка городов» можно использовать как синонимы. Каждому маршруту соответствует перестановка, и каждой перестановке соответствует маршрут --- в котором города обходятся в том порядке, в каком они записаны в перестановке.} трёх городов в лексикографическом порядке. 


\subsect{Квантовая цепь}

На рис. \ref{circuit} изображена использованная нами квантовая схема. Она состоит из слоя гейтов Rx, за которым идёт слой гейтов CNOT. 
В схему можно добавить ещё несколько таких пар слоёв, но мы не стали этого делать.
Гейты поворота Rx имеют параметры: углы $\theta_i$. Обсудим, почему мы выбрали эту схему.

\fig[0.66]{circuit}{Квантовая схема, использованная в разработанном алгоритме}

Нам было нужно параметрически создавать квантовое состояние, которое соответствует какому-то маршруту или их суперпозиции. Исходя из этого, мы выдвинули три требования к квантовой цепи:

\begin{enumerate}
    \item все состояния-маршруты должны быть «достижимыми»: для каждого маршрута должен существовать набор параметров такой, что на выходе цепи должно получиться состояние, соответствующее этому маршруту 

    \item все достижимые состояния должны быть «корректными»: при любом наборе параметров на выходе цепи должна получаться суперпозиция допустимых маршрутов
    
    %\item все параметрические гейты должны иметь вид $U(\theta) = \exp\brk!{i \frac{\theta}{2} \hat H}$, где $\hat H^2 = \hat 1$ --- это позволит применить алгоритм подбора параметров Rotosolve, который мы обсудим в следующем разделе.

    \item параметрические гейты должны позволять использовать алгоритм Rotosolve, который мы обсудим в следующем разделе. Он применим к широкому классу гейтов, но не ко всем.
\end{enumerate}


Ранее мы выбрали способ представления маршрутов (через их номер), в котором все состояния, составляющие вычислительный базис, соответствуют какому-то допустимому маршруту. А совершенно произвольное состояние, таким образом, соответствует некоторой суперпозиции допустимых маршрутов, и требование (2) выполнено автоматически.

Требование достижимости (1) тоже выполнено. В этом несложно убедиться, если сначала заметить, что для создания произвольного маршрута (двоичного числа, символизирующего его номер) было бы достаточно одного слоя гейтов Rx. Углы в остальных слоях (если они есть) можно положить равными 0, тогда останутся только гейты CNOT, которые легко обращаются.

% Ограничение (3) на количество собственных значений тоже выполнено, поскольку гейты Rx 
% % $\text{X} = \text{Rx}(\pi)$ 
% однокубитные, имеют матрицу $2 \times 2$ и два собственных значения.

Чтобы выполнить все ограничения, гейты CNOT не понадобились. Однако они устанавливают связь между кубитами, поэтому мы их добавили. Это улучшило результат в симуляции.

Обсудим также то, как кубиты должны быть соединены между собой на физическом устройстве. 
%Это остаётся большой проблемой
Эта тема остаётся «больным местом» 
% для
физических реализаций квантовых компьютеров. Никому до сих пор не удалось создать квантовый компьютер, в котором каждый кубит был бы связан с каждым, и это вряд ли изменится когда-либо в обозримом будущем.

К счастью, в нашей схеме двухкубитные гейты производятся только над соседними кубитами, следовательно, кубитам достаточно просто быть соединёнными в линию (рис. \ref{qubitConnectivity}).

\fig[0.45]{qubitConnectivity}{Required qubit connectivity}

Квантовые компьютеры с такой простой структурой можно ожидать в ближайшем будущем.

%взять произвольный маршрут, записать его номер в двоичной системе (например $\ket{1010}$), положить углы поворота $\theta_i$ равными нулю во всех слоях кроме первого, применить гейты CNOT в обратном порядке

\subsect{Алгоритм Rotosolve для подбора параметров}

Наша схема содержит гейты поворота $\operatorname{Rx}(\theta)$, и в ходе алгоритма мы пытаемся подобрать оптимальные углы $\theta$, минимизирующие среднюю стоимость состояния, получающегося на выходе. Для этого мы могли бы использовать любой алгоритм поиска минимума функции, например метод градиентного спуска.

Но в \citedate{rotosolve} году Ostaszewski et al. \cite{rotosolve} предложили более эффективный алгоритм, названный Rotosolve. Они заметили, что большинство доступных квантовому компьютеру параметрических гейтов может быть представлено в виде
\begin{equation}
\hat U(\theta) 
= \exp\brk2{-\frac{i \theta}{2} \hat H}
= \cos\brk2{\frac{\theta}{2}} \hat 1 - i \sin\brk2{\frac{\theta}{2}} \hat H,
\label{eq:exp}
\end{equation}
где $\hat H$ --- это некоторая унитарная эрмитова матрица --- такая, что $\hat H^2 = \hat 1.$

В частности, при 
$\hat H = \hat \sigma_x,\, \hat \sigma_y,\, \hat \sigma_z$
мы получаем знакомые гейты поворота Rx, Ry, Rz.
%Формула \eqref{eq:exp} отражает тот факт, что на квантовом компьютере мы делаем гейты, посылая на кубит некоторый импульс и 
Физический смысл параметра $\theta$ заключается во времени воздействия на кубит.

%Если мы теперь посчитаем среднее значение 

%Из формулы \eqref{eq:exp} после некоторых преобразований можно

Из формулы \eqref{eq:exp} видно, что если зафиксировать параметры всех гейтов, кроме одного, то математическое ожидание произвольной наблюдаемой $C$ будет иметь синусоидальную форму:
$$
\brk[a]{C}_\theta = a \sin(\theta + b) + c
$$
Если мы сможем оценить коэффициенты $a$, $b$ и $c$, то мы сможем охарактеризовать синусоиду и найти минимум. Авторы показали, что он с точностью до $2\pi k$ даётся выражением в замкнутой форме
\begin{align*}
\theta^* 
&= \argmin_\theta \: \brk[a]{C}_\theta = \\
&= \theta_0 - \frac{\pi}{2} - \arctantwo \brk*{
   2\brk[a]{C}_{\theta_0} - 
    \brk[a]{C}_{\theta_0 + \frac{\pi}{2}} - 
    \brk[a]{C}_{\theta_0 - \frac{\pi}{2}}
    ,\quad
    \brk[a]{C}_{\theta_0 + \frac{\pi}{2}} - 
    \brk[a]{C}_{\theta_0 + \frac{\pi}{2}}
},
\end{align*}
где $\theta_0$ --- произвольная начальная точка.

Алгоритм Rotosolve оптимизирует углы для всех гейтов по очереди, затем цикл повторяется, пока не выполнится критерий остановки. 

\subsect{Критерий остановки}

Выбор критерия остановки нетривиален, поскольку функция, которую мы минимизируем, зашумлена из-за взаимодействия кубитов со средой и из-за случайности самого акта измерения.

В ходе алгоритма значения параметров обновляются циклически. Обозначим $c[i][j]$ --- значения целевой функции на $i$-том цикле перед обновлением $j$-того параметра.%, $l$ --- количество параметров.

В качестве критерия остановки можно использовать:

\begin{enumerate}
    \item ограничение на максимальное число итераций
    \item $c[i-1][0] - c[i][0] < \textsl{tol}$
    \item $\abs2{c[i-1][0] - c[i][0]} < \textsl{tol}$
    \item $\norm2{\brk1{\vec \theta[i] - \vec \theta[i-1] + \pi} \mathbin{\%} 2\pi - \pi} < \textsl{tol}$,
\end{enumerate}

где $\vec \theta [i]$ --- вектор параметров перед $i$-тым циклом обновления, \textsl{tol} --- фиксированное маленькое число. 

Из-за шумов значение функции на последующем шаге может быть больше, чем на предыдущем, поэтому критерии (2) и (3) не эквивалентны.

Вслед за разработчиками библиотеки TensorFlow Quantum \cite{tfq} мы используем комбинацию вариантов (1) и (3). Но другие критерии тоже возможны и имеют свои преимущества. Например, критерий (4) позволяет выбрать величину \textsl{tol} не зависящей от характерного масштаба значений функции. 

То, как на практике работают данные критерии остановки, иллюстрирует рис. \ref{diminishing}:

%Мы запустили алгоритм несколько раз из различных случайных начальных точек, построили график уменьшения стоимости и отметили точки, где сработали бы различные критерии остановки (рис. ):

\fig[0.6]{diminishing}{
\justifying
Ход оптимизации и точки, в которых сработали бы различные критерии остановки. Разные линии соответствуют разным случайным начальным точкам. Использовался случайный граф из 6 городов (720 возможных решений). 
Каждые 10 шагов начинается новый цикл обновления параметров.
Мы выбрали критерий «\(|\Delta c| < 0.01\)» для дальнейшего использования.}

Неправильно выбранный критерий остановки может заставить алгоритм совершать лишние итерации или наоборот заставить остановить итерации слишком рано.

Отметим, что не обязательно в условии остановки использовать только две точки. Так, например, в книге \cite{cross-entropy} предлагается использовать критерии, основанные на скользящем среднем. Сравнение разных критериев остановки может быть стоящим направлением будущих исследований, как в применении к нашей задаче, так и для вариационных квантовых алгоритмов в целом.

%(например, достижение максимального числа итераций или отсутствие значимого уменьшения за $K$ последовательных циклов).

%В Rotosolve оптимальные углы для каждого гейта находятся последовательно, а затем цикл повторяется

% Мы используем реализацию алгоритма из TensorFlow Quantum \cite{tfq}.

% \cite{cirq}

\sect{Оценки эффективности алгоритма}

Мы протестировали наш алгоритм на случайных графах с 4--10 городами (от 24 до 3\,628\,800 возможных решений). 
Стоимости путей между всеми парами городов генерировались равномерно на отрезке [0,~1]. 
Мы рассмотрели самую общую задачу, когда стоимость пути может быть разной в зависимости от направления.

\subsect{Качество решений}

Для начала рассмотрим случай 4 городов. Мы построили распределения стоимостей на входе и на выходе алгоритма (рис. \ref{4towns}). 
Вообще говоря, алгоритм Rotosolve детерминистический: каждая следующая точка в пространстве параметров однозначно определяется предыдущей. Однако мы, во-первых, запускали его из различных случайных начальных точек, и во-вторых, оценивали матожидание стоимости с помощью сэмплирования, что вносит случайную ошибку. Из-за этого, запуская алгоритм несколько раз на одном графе, мы получали разные результаты. Их распределение и изображено на рис. \ref{4towns}.

\fig[0.6]{4towns}{
\justifying
Оранжевое: распределение стоимостей всех возможных $n!$ ($n = 4$) маршрутов.
Синее: распределение стоимостей решений, к которым приходит алгоритм при старте из различных случайных начальных точек. 
Чёрной точкой на оси $X$ отмечена стоимость точного решения. В большинстве случаев решение совпадало с точным, это соответствует высокому левому пику. Он имеет ненулевую ширину из-за того, что при построении графика использовался метод ядерной оценки плотности.
}

Из рисунка \ref{4towns} видно, что в случае 4 городов алгоритм практически всегда выдаёт точное решение. К сожалению, при большем числе городов такого чуда больше не происходит. Однако алгоритм продолжает стабильно выдавать решения с маленькой стоимостью.

Чтобы убедиться в этом, мы построили аналогичные распределения 
%стоимостей решений 
при другом числе городов и объединили их в одну скрипичную диаграмму (рис. \ref{violin}). Для удобства сопоставления мы отнормировали стоимость на среднее по всем перестановкам. Это среднее приблизительно равно $\frac{n-1}{2}$, поскольку стоимость каждого ребра равномерно распределена на [0, 1], а таких рёбер в незамкнутом маршруте ровно $n-1$.

\fig[0.9]{violin}{
\justifying
Скрипичная диаграмма стоимостей до и после оптимизации. 
По оси $Y$ отложена стоимость, нормированная на среднее. \\
Синее: распределение стоимостей решений, к которым приходит алгоритм при старте из различных случайных начальных точек. \\
Оранжевое: распределение стоимостей всех $n!$ возможных маршрутов. \\
Толщина символизирует сглаженную плотность вероятности.
%по методу ядерной оценки плотности. 
Чёрными точками отмечены точные решения.
}

Из рисунка \ref{violin}, во-первых, видно, что оранжевое распределение при росте числа городов в силу центральной предельной теоремы стремится к нормальному. Во-вторых, синее распределение не смещается вверх, это означает, что алгоритм продолжает выдавать решения одного качества при любом числе городов, их стоимость составляет около 0.5 от средней.

\subsect{Сложность}

Вычислительная сложность --- едва ли не самая главная характеристика алгоритмов.

В данном алгоритме параметры обновляются циклически, каждое обновление параметра требует 3 вычисления функции. Обозначим количество циклов как $K$, а количество параметров как $l = \lceil \log_2 n! \rceil = O(n \log n)$. Тогда сложность алгоритма равна
$$
O(K \cdot n \log n)
$$

Чтобы оценить количество циклов, которое понадобится алгоритму, чтобы сойтись, мы построили следующий график (рис. \ref{ncycles}):

\fig[0.56]{ncycles}{
%\justifying
Зависимость количества циклов $K$ обновления параметров от числа городов. Планки означают стандартное отклонение, точки означают среднее по большому количеству запусков с разными случайными начальными точками.
}

Как видно из графика, количество циклов приблизительно линейно, то есть $K = O(n)$. Окончательно, сложность нашего алгоритма равна
$$
O(n^2 \log n) \quad \text{вычислений стоимости},
$$
что значительно лучше классических алгоритмов ($n!$ для простого перебора и $n^2 2^n$ у алгоритма Хелда--Карпа). Однако наш алгоритм выдаёт не совсем оптимальные решения, поэтому для сравнения алгоритмов понадобились провести более полный анализ.

\subsect{Сравнение с простым перебором}

Предположим, мы запустили наш алгоритм на некоторых входных данных, и после $M$ итераций получили решение со стоимостью $c$. Хорошо это или плохо?

Введём величину $p(c)$ --- долю решений со стоимостью, меньшей или равной $c$ (процентильный ранг). Заметим, что в случае простого перебора
$$
M \cdot p(c) \approx 1,
$$
где $M = \textsl{nfev}$ --- количество вычислений целевой функции. Например, чтобы получить решение из лучших 50\%, в среднем достаточно двух попыток, а чтобы получить наилучшее решение $\brk!{p(c) = 1/n!}$, требуется перебрать $n!$ кандидатов.

Мы можем вычислить величину $M \cdot p(c)$ для нашего алгоритма и сравнить с единицей (рис. \ref{percentile}). Если она меньше единицы, то алгоритм лучше простого перебора, если больше, то хуже.

\fig[0.58]{percentile}{
\justifying
Распределение величины $M \cdot p(c)$, где $M$ --- количество вычислений функции $\brk[a]{\text{cost}} = f(\vec \theta)$, $\vec \theta$ --- вариационные параметры, $p(c)$ --- процентильный ранг решения, к которому пришёл алгоритм.
Незатенённая область соответствует случаю, когда $M \cdot p(c) < 1$ и разработанный алгоритм оказывается производительнее простого перебора.
}

Рисунок \ref{percentile} показывает, что с ростом числа городов величина $M \cdot p(c)$ в среднем уменьшается, и при 10 городах она оказывается меньше единицы более чем в половине запусков. 

Но нужно отметить, что при построении графика мы в качестве \textsl{nfev} брали количество вычислений функции $\brk[a]{\text{cost}}$ --- средней стоимости по суперпозиции. Чтобы её вычислить, нужно измерить квантовое состояние несколько раз (в нашей симуляции \textsl{n\_samples} = 100 раз). 

Более честная версия графика \ref{percentile} выглядела бы растянутой по оси $Y$ в \textsl{n\_samples} раз. Следовательно, при 10 городах квантовое преимущество всё ещё не будет достигнуто. Будет ли оно достигнуто при большем числе городов~--- открытый вопрос. Величина на графике \ref{percentile} уменьшается, что позволяет надеяться, что она достигнет 1 даже при умножении на \textsl{n\_samples}, однако мы не можем просимулировать цепи с таким большим количеством кубитов.

\subsect{Используемые ресурсы}

Нашему алгоритму требуется $\lceil \log_2 n! \rceil = O(n \log n)$ кубитов (где $n$ --- число городов), поскольку мы храним на квантовом компьютере одно целое число $x \in [0,\ n!)$.

Это значительно меньше, чем в других алгоритмах, которые, как правило, хранят маршрут в виде $n^2$ или даже $n^3$ бинарных переменных (см. подраздел 2.3 в «Обзоре литературы»):

\fig[0.8]{qubits}{
%\justifying
Количество кубитов, необходимое для нашего алгоритма $(log_2 n!)$ и для алгоритмов, сводящих задачу коммивояжёра к задаче квадратичной бинарной оптимизации $(n^2).$ 
Мы не стали дискретизировать данный график.
}

Осенью 2021 года компания IBM объявила о создании 127-кубитного квантового компьютера \cite{IBM-127}. На таком компьютере наш алгоритм сможет искать решение задачи коммивояжёра с 33 городами, что соответствует $8.68 \cdot 10^{36}$ возможным маршрутам.


\sect{Проблемы алгоритма и направления будущих исследований}

\subsect{Получение решения, произвольно близкого к точному}

Как видно из рисунка \ref{violin}, наш алгоритм в случае случайных графов в среднем позволяет получать решения со стоимостью приблизительно вдвое меньше средней стоимости. 
Но что делать, если в практической задаче понадобится найти решение, более близкое к оптимальному?

Один из способов, которые теоретически могут сработать, --- это использовать многослойную схему (рис. ). Многослойная вариационная цепь подобна многослойной нейронной сети. У неё больше параметров, что может позволить ей лучше находить решения. 

\fig[0.7]{circuit2layers}{
\justifying
Схема с двумя слоями. Количество слоёв можно увеличивать неограниченно. Заметим, что без гейтов CNOT увеличивать глубину цепи не получилось бы, так как два идущих подряд гейта Rx эквивалентны одному.}

% В описании написать что без CNOT-гейтов многослойности бы не получилось

Мы протестировали двухслойную цепь на графе из 6 городов и сравнили её с однослойной (рис. \ref{layers}):

\fig[0.6]{layers}{Распределения стоимостей решений, которые получаются при использовании однослойной и двухслойной цепи.}

Видно, что решения, полученные двухслойной цепью, в чаще имеют меньшую стоимость, чем решения, полученные с помощью однослойной. Это имеет свою цену: в случае двухслойной цепи понадобилось больше повторных измерений (500 вместо 100), чтобы с достаточной точностью вычислять стоимость состояния. Дальнейшее увеличение числа слоёв к успеху не привело. 

Возможно, имеет смысл использовать другие цепи и наборы параметрических гейтов. При этом можно опираться на работу \cite{Expressibility} (\citeyear{Expressibility}), в которой есть обзор различных вариационных квантовых цепей без привязки к какой-либо конкретной задаче.

Кроме того, в будущих исследованиях имеет смысл рассмотреть различные критерии остановки (см. раздел 3.4). 
% В данной работе мы использовали очень простой критерий остановки, но 
Возможно, именно правильный критерий остановки, учитывающий шумы, позволит неограниченно увеличивать число слоёв в цепи и точность алгоритма в целом.


\subsect{Переиспользование подобранных параметров}

%У широко изученного алгоритма QAOA есть одно преимущество по сравнению с разработанным нами алгоритмом.

В разделе «Обзор литературы» мы обсуждали QAOA --- широко изученный вариационный квантовый алгоритм. Его сложно напрямую применить к задаче коммивояжёра, но у него есть одно преимущество по сравнению с разработанным нами алгоритмом. 

Если решать схожие между собой задачи, отличающиеся только числами, то при использовании QAOA оптимальные вариационные параметры оказываются почти одинаковыми \cite{Params} (\citeyear{Params}). Это позволяет использовать результат одной задачи в качестве начального приближения для другой, сильно уменьшая число итераций.

В нашем алгоритме это не так. Если мы возьмём подобранные параметры от другой задачи, то мы получим ответ для другой задачи.

Но попытка перенять это свойство QAOA может быть одним из направлений будущих исследований. Для этого потребуется:

\begin{enumerate}
    \item отразить в квантовой цепи структуру задачи, например, в QAOA для этого применяют оператор $e^{i \hat H t}$, где $\hat H$ --- оператор стоимости.
    
    \item использовать в качестве начального состояния равную суперпозицию.
\end{enumerate}

На данный момент в нашем алгоритме в качестве начального используется состояние $\ket{0}^{\otimes\, m}$. Оно соответствует перестановке под номером 0. 

Чтобы сгенерировать равную суперпозицию всех допустимых решений, нужно сгенерировать равную суперпозицию чисел от $\ket{0}$ до $\ket{n!-1}$. Если бы $n!$ было степенью двойки, то можно было бы просто применить ко всем кубитам гейт Адамара. В общем же случае можно использовать обобщённый алгоритм усиления амплитуды, как показано в \cite{perms} (\citeyear{perms}). 

В той же работе \cite{perms} описан способ сгенерировать суперпозицию самих перестановок, а не только их номеров. Это может быть полезно для того, чтобы попытаться отразить в квантовой цепи структуру задачи.

\subsect{Применение к другим задачам}

Наш алгоритм легко обобщается на другие задачи, в которых решения-кандидаты могут быть каким-то образом пронумерованы. Точно так же квантовый компьютер будет использоваться для создания суперпозиции нескольких номеров, а на классическом компьютере будут вычисляться соответствующие стоимости.

Для этого достаточно, чтобы существовал эффективный классический алгоритм получения решения по его номеру. Это, во-первых, задачи, в которых, как и в задаче коммивояжёра, допустимыми ответами являются перестановки, например, задача о назначениях. Во-вторых, это задачи, в которых допустимыми ответами являются сочетания. 

И перестановки, и сочетания можно сортировать в лексикографическом порядке и затем восстанавливать решения по их номерам. 
Для этого используется факториальная и комбинаторная система счисления соответственно.
Подробный анализ алгоритмов приведён в работе \cite{Combinations} (\citeyear{Combinations}).

\structel{ЗАКЛЮЧЕНИЕ}

Мы разработали вариационный квантовый алгоритм для задачи коммивояжёра. Мы оценили его сложность как $O(n^2 \log n)$, а количество требуемых кубитов как $O(n \log n)$.

Разработанный алгоритм является приближённым и не всегда позволяет получить точное решение. 
Это естественно, поскольку мы пытались решить неполиномиальную задачу за полиномиальное время. 
Однако, во-первых, по соотношению сложность / качество решений наш алгоритм превосходит простой перебор. 
Во-вторых, предварительные данные показывают, что точность алгоритма можно улучшить, как описано в разделе 5.1.

Наш алгоритм требует, чтобы кубиты на квантовом компьютере были соединены в линию. Такая простая топология позволяет использовать алгоритм на существующих квантовых компьютерах. Маленькая глубина цепи (всего 3 гейта) позволяет использовать кубиты с маленьким временем декогеренции. 

В процессе создания алгоритма мы разработали новый способ представления маршрутов на квантовом компьютере.
Он основан на том, что все возможные маршруты можно пронумеровать в лексикографическом порядке.
Мы использовали тот факт, что на классическом компьютере по номеру маршрута можно быстро восстановить сам маршрут, переведя его в факториальную систему счисления.
Наше представление автоматически учитывает нетривиальные ограничения задачи, касающиеся того, чтобы маршрут проходил через все города и не распадался на не связанные друг с другом петли.

Наш алгоритм можно обобщить на другие задачи, в которых решения можно каким-либо эффективным образом пронумеровать. К таким относится, например, комбинаторная задача о назначениях.


% \newpage

% Значение четвертого члена числовой последовательности Фибоначчи определяется
% по формуле~\eqref{eq:fib}.

% \begin{multline}\label{eq:fib}
%     F(4) = F(3) + F(2) = \\
%     = F(2) + F(1) + F(1) + F(0) = F(1) + F(0) + \\
%     + F(1) + F(1) + F(0) = 3F(1) + 2F(0) = 3
% \end{multline}

% где $F(1)$ --- первый член последовательности, равный $1$,\\
% $F(0)$ --- нулевой член последовательности, равный $0$.

% Документация \cite{bib}.

% Хорошая статья \cite{ml}.

\sloppy
\showbib

% \annex{Очень интересная схема Очень интересная схема Очень интересная схема}

\end{document} 
