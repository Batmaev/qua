\input{./gost-template/preamble.tex}

\usepackage{microtype}
\usepackage[extdef]{delimset}

\begin{document}

\setcounter{page}{2}

\hidedstructel{АННОТАЦИЯ}

% Пояснительная записка \pageref{LastPage} с., \total{figcount} рис.,
% \total{tblcount} табл., \total{bibcount} источн., \total{annexcount} прил.


Цель работы --- разработать вариационный квантовый алгоритм для задачи коммивояжёра. Полученные результаты ??? Рекомендации на основе данной работы ??

\input{./gost-template/toc.tex}

\structel{ВВЕДЕНИЕ}

Эта работа посвящена вариационным квантовым алгоритмам в задачах оптимизации. Вариационные алгоритмы так называются, потому что в них квантовый компьютер запускается снова и снова с небольшими изменениями в параметрах квантовой цепи. Процессом варьирования управляет классический компьютер. Его задача --- подобрать параметры цепи такие, чтобы на выходе получалось оптимальное по некоторому заданному критерию состояние.

Уже разработаны вариационные квантовые алгоритмы для задач из нескольких разных областей. Среди них --- алгоритмы поиска собственных значений матрицы, максимального разреза графа и другие. Они позволяют решать задачи на существующих квантовых компьютерах --- подверженных шумам и оперирующим малым числом кубитов.

Данная работа фокусируется на задаче коммивояжёра, для которой эффективного квантового алгоритма пока не существует. Особенностью этой задачи является наличие ограничений: например, коммивояжёр не может посетить один город дважды. 

Традиционно ограничения в вариационных квантовых алгоритмах реализуются через дополнительные штрафные слагаемые к оптимизируемой величине. Но мы вместо этого попробуем добиться того, чтобы состояние, не удовлетворяющее ограничениям, в принципе невозможно было измерить.

Такая реализация ограничений задачи непосредственно через саму квантовую цепь --- главное направление этой работы, в этом заключается её новизна и возможная научная значимость.

Настоящие квантовые компьютеры всё ещё не широко доступны, поэтому мы тестируем алгоритм с помощью компьютерной симуляции. Для этого мы используем \texttt{cirq} --- библиотеку для Python от Google Quantum AI.

\sect{Классические подходы}

\subsect{Постановка задачи коммивояжёра}

В задаче коммивояжёра есть $n$ городов, соединённых друг с другом, и требуется найти кратчайший маршрут, проходящий через все города по одному разу.

Существует несколько вариаций задачи. Маршрут может быть замкнутым или незамкнутым, расстояния между городами могут подчиняться или не подчиняться неравенству треугольника; граф городов может быть полным или неполным, ориентированным или неориентированным. Все эти разновидности можно свести друг к другу, поэтому мы можем выбрать ту формулировку, которая кажется наиболее удобной. 

Итак, пусть каждый город соединён с каждым (т.е. граф городов полный), пусть мы ищем незамкнутый маршрут и пусть граф городов ориентированный. Ориентированность означает, что условная длина (или стоимость) пути из города $A$ в город $B$ не обязательно равна стоимости пути из $B$ в $A$.

Введём обозначение
\[
l_{ij} - \text{ длина пути из $i$-того города в $j$-тый}
\]

Ответом на задачу служит последовательность городов. Есть $n$ способов выбрать первый город, $n-1$ способ выбрать второй и так далее --- всего $n!$ возможных ответов. Если бы мы выбрали другую формулировку задачи, то пришлось бы, например, учитывать, что в замкнутом пути начальную точку можно выбрать несколькими способами.

Простейший алгоритм --- перебрать все возможные перестановки --- будет иметь сложность $O(n!)$ по времени и $O(1)$ по памяти.

\subsect{Алгоритм Хелда-Карпа}

Альтернативой является алгоритм Хелда-Карпа, который имеет сложность $O(n^2 2^n)$ по времени и $O(n 2^n)$ по памяти. Это лучший классический алгоритм из тех, которые гарантированно приходят к точному решению.\footnote{Ещё есть эвристические приближённые алгоритмы} Для нашей постановки задачи алгоритм выглядит следующим образом:

\begin{enumerate}

    \item Создаётся мнимый нулевой город, связанный со всеми остальными городами дорогами длины 0.
    
    \item Определяется рекурсивная функция $g(S, e)$, возвращающая длину наименьшего пути, начинающегося в городе 0, проходящего через каждый город некоторого подмножества городов $S$ и заканчивающегося в городе $e \notin S$. 
    
    \item Эта функция вычисляется следующим образом:
    \[
    g(S,e) = \min_{e' \in S} \brk[c]2{
        g(S\backslash e',\, e') + l_{e'e}
    }
    \]
    (через перебор всех возможных вариантов для предпоследнего города $e'$)

    \item Существует $2^n$ возможных множеств $S$. Если последовательно вычислять $g(S,e)$ от меньших множеств к большим, перебирая все $e \notin S$, то мы сможем использовать уже вычисленные значения $g$, и <<входить в рекурсию>> не потребуется. Функция $g$ будет вызвана $O(n2^n)$ раз, и на хранение результатов потребуется $O(n2^n)$ памяти.
    
    \item При каждом вызове функции $g(S,e)$ происходит перебор $O(n)$ возможных предпоследних вершин $e'$, поэтому сложность функции $g$ --- $O(n)$, а сложность алгоритма в целом --- $O(n^2 2^n)$.
    
    \item В конце вычисляется $g(S_n, 0)$, где $S_n$ --- множество всех городов. Это и будет длиной искомого минимального пути.
    
    \item Можно восстановить и сам оптимальный путь, а не только его длину, если в ходе решения помимо промежуточных значений функции $g(S,e)$ сохранять номера оптимальных предпоследних вершин $e'$. Это не повлияет на асимптотику алгоритма.

\end{enumerate}

Алгоритм Хелда-Карпа работает быстрее, чем простой перебор, но требует экспоненциально много памяти. 



% \newpage

% Значение четвертого члена числовой последовательности Фибоначчи определяется
% по формуле~\eqref{eq:fib}.

% \begin{multline}\label{eq:fib}
%     F(4) = F(3) + F(2) = \\
%     = F(2) + F(1) + F(1) + F(0) = F(1) + F(0) + \\
%     + F(1) + F(1) + F(0) = 3F(1) + 2F(0) = 3
% \end{multline}

% где $F(1)$ --- первый член последовательности, равный $1$,\\
% $F(0)$ --- нулевой член последовательности, равный $0$.

% Документация \cite{bib}.

% Хорошая статья \cite{ml}.

% \showbib

% \annex{Очень интересная схема Очень интересная схема Очень интересная схема}

\end{document} 
